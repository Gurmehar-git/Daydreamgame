<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hero’s Sacrifice</title>
<style>
  :root { --bg:#0b0f14; --card:#111826; --text:#e7edf5; --muted:#96a2b4; --primary:#6aa6ff; --accent:#ffd54a; --danger:#ff5a5f; --border:#223146; }
  *{box-sizing:border-box} html,body{height:100%;margin:0}
  body{
    background:radial-gradient(1200px 600px at 50% -100px,#1a2433 0%,#0b0f14 60%);
    color:var(--text); font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;
    display:grid; place-items:center;
  }
  .wrap{width:100%;max-width:960px;padding:24px}
  .hud{display:flex;gap:16px;align-items:center;margin-bottom:12px;font-weight:700}
  .hud .tag{padding:6px 10px;border:1px solid var(--border);border-radius:10px;background:#0f1624aa;backdrop-filter:blur(4px)}
  .canvas-wrap{border:4px solid var(--border);border-radius:16px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,.45)}
  canvas{display:block;background:transparent;outline:none}
  .controls{display:flex;gap:8px;margin-top:10px}
  button{background:#122037;color:var(--text);border:1px solid var(--border);padding:8px 14px;border-radius:10px;cursor:pointer}
  button:hover{background:#162744}

  .screen{
    position:fixed; inset:0; display:none; place-items:center; padding:24px;
    background:rgba(5,8,12,.65); backdrop-filter:blur(6px); z-index:10; pointer-events:none;
  }
  .screen.visible{ display:grid; pointer-events:auto; }
  .card{ width:min(680px,90vw); background:var(--card); border:1px solid var(--border);
    border-radius:16px; padding:28px; box-shadow:0 10px 40px rgba(0,0,0,.5) }
  .card h1,.card h2{margin:0 0 10px}
  .card p{color:var(--muted)}
  .card .actions{margin-top:18px;display:flex;gap:10px}
  .btn-primary{background:#1c3b70;border-color:#31548a}
  .btn-primary:hover{background:#20437d}
  .btn-danger{background:#5a1620;border-color:#7a2030}

  .toasts{position:fixed;top:16px;right:16px;display:grid;gap:8px;z-index:20}
  .toast{background:#0f1a2c;border:1px solid var(--border);color:var(--text);padding:8px 12px;border-radius:8px;opacity:0;transform:translateY(-8px);animation:toast 2.2s ease forwards}
  @keyframes toast{0%{opacity:0;transform:translateY(-8px)}10%{opacity:1;transform:translateY(0)}90%{opacity:1}100%{opacity:0;transform:translateY(-8px)}}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="tag">Lives: <span id="lives">3</span></div>
      <div class="tag">Score: <span id="score">0</span></div>
      <div class="tag">Level: <span id="level">1</span>/10</div>
    </div>
    <div class="canvas-wrap">
      <canvas id="game" width="800" height="400" tabindex="0" aria-label="Game canvas"></canvas>
    </div>
    <div class="controls">
      <button id="btn-skip" title="Debug">Skip Level</button>
      <button id="btn-menu">Menu</button>
    </div>
  </div>

  <!-- Overlays -->
  <div id="screen-menu" class="screen visible">
    <div class="card">
      <h1>Hero’s Sacrifice</h1>
      <p>Save your brother from the Dragon King. Every step forward costs something.</p>
      <div class="actions">
        <button class="btn-primary" id="start">Start Adventure</button>
      </div>
    </div>
  </div>

  <div id="screen-story" class="screen">
    <div class="card">
      <h2 id="story-title">Level 1: The Journey Begins</h2>
      <p id="story-text"></p>
      <div class="actions">
        <button class="btn-primary" id="continue">Continue</button>
      </div>
    </div>
  </div>

  <div id="screen-gameover" class="screen">
    <div class="card">
      <h2 style="color:var(--danger);">Game Over</h2>
      <p>Lives remaining: <span id="lives-remaining">0</span></p>
      <div class="actions">
        <button class="btn-primary" id="try-again">Try Again</button>
        <button class="btn-danger" id="restart">Restart</button>
      </div>
    </div>
  </div>

  <div id="screen-victory" class="screen">
    <div class="card">
      <h2 style="color:var(--accent);">Victory!</h2>
      <p>Through courage and sacrifice, you saved your brother.</p>
      <p><strong>Final Score: <span id="final-score">0</span></strong></p>
      <div class="actions">
        <button class="btn-primary" id="play-again">Play Again</button>
      </div>
    </div>
  </div>

  <div class="toasts" id="toasts"></div>

  <script>
  'use strict';
  window.addEventListener('DOMContentLoaded', () => {
    // --- constants ---
    const W=800,H=400, GRAVITY=.5, JUMP=-12, SPEED=4;

    // --- camera / world sizing ---
    const DEFAULT_LEVEL_WIDTH = 2000;
    const VIEW_MARGIN_X = 180;
    let camX = 0;

    // --- dom refs + fallbacks ---
    const q=(id)=>document.getElementById(id);

    function ensureCanvas(){
      let c = document.getElementById('game');
      if(!c){
        const wrap = document.querySelector('.canvas-wrap') || document.body;
        c = document.createElement('canvas');
        c.id='game'; c.width=800; c.height=400; c.setAttribute('tabindex','0');
        wrap.appendChild(c);
      }
      return c;
    }
    function ensureToasts(){
      let t = document.getElementById('toasts');
      if(!t){ t=document.createElement('div'); t.id='toasts'; t.className='toasts'; document.body.appendChild(t); }
      return t;
    }

    const canvas=ensureCanvas();
    const ctx=canvas.getContext('2d');

    const elLives=q('lives'), elScore=q('score'), elLevel=q('level'), elToasts=ensureToasts();
    const $menu=q('screen-menu'), $story=q('screen-story'), $gameover=q('screen-gameover'), $victory=q('screen-victory');
    const elStoryTitle=q('story-title'), elStoryText=q('story-text'), elLivesRemaining=q('lives-remaining'), elFinalScore=q('final-score');

    const btnStart=q('start'), btnContinue=q('continue'), btnTryAgain=q('try-again'),
          btnRestart=q('restart'), btnPlayAgain=q('play-again'), btnSkip=q('btn-skip'), btnMenu=q('btn-menu');

    [$menu,$story,$gameover,$victory].forEach(s=>{ if(s){ s.style.pointerEvents='none'; } });
    const show=(el,vis)=>{ if(!el) return; el.classList.toggle('visible',vis); el.style.pointerEvents=vis?'auto':'none'; };

    // --- base levels (we’ll enhance) ---
    const levels=[
      {id:1,name:"The Journey Begins",theme:'overworld',story:"Alex is taken by the Dragon King. A witch offers help—at a price.",
        platforms:[{x:0,y:368,w:900,h:32,type:'ground'},{x:200,y:300,w:64,h:16,type:'brick'},{x:350,y:250,w:64,h:16,type:'brick'},{x:500,y:200,w:64,h:16,type:'brick'}],
        enemies:[{x:300,y:336,w:32,h:32,type:'goomba',vx:-1}]},
      {id:2,name:"Underground Tunnels",theme:'castle',story:"Every step deeper leaves safety behind.",
        platforms:[{x:0,y:368,w:200,h:32,type:'ground'},{x:220,y:320,w:80,h:16,type:'brick'},{x:380,y:280,w:60,h:16,type:'brick'},{x:520,y:330,w:80,h:16,type:'brick'}],
        enemies:[{x:240,y:288,w:32,h:32,type:'goomba',vx:-1},{x:560,y:298,w:32,h:32,type:'goomba',vx:1}]},
      {id:3,name:"Lava Caverns",theme:'lava',story:"Cross the burning depths.",
        platforms:[{x:0,y:368,w:150,h:32,type:'ground'},{x:200,y:300,w:64,h:16,type:'brick'},{x:340,y:350,w:80,h:50,type:'lava'},{x:520,y:250,w:64,h:16,type:'brick'}],
        enemies:[{x:540,y:218,w:32,h:32,type:'goomba',vx:-1}]},
      {id:4,name:"Skyward Ascent",theme:'overworld',story:"Each leap upward costs something.",
        platforms:[{x:0,y:368,w:120,h:32,type:'ground'},{x:180,y:320,w:64,h:16,type:'brick'},{x:320,y:270,w:64,h:16,type:'brick'},{x:460,y:220,w:64,h:16,type:'brick'}],
        enemies:[{x:200,y:288,w:32,h:32,type:'goomba',vx:-1}]},
      {id:5,name:"Frozen Peaks",theme:'ice',story:"Let determination burn warm.",
        platforms:[{x:0,y:368,w:180,h:32,type:'ice'},{x:240,y:300,w:100,h:16,type:'ice'},{x:420,y:250,w:64,h:16,type:'ice'}],
        enemies:[{x:260,y:268,w:32,h:32,type:'goomba',vx:-1}]},
      {id:6,name:"The Gauntlet",theme:'lava',story:"Let courage outgrow fear.",
        platforms:[{x:0,y:368,w:100,h:32,type:'ground'},{x:160,y:320,w:50,h:16,type:'brick'}],
        enemies:[{x:180,y:288,w:32,h:32,type:'goomba',vx:-1}]},
      {id:7,name:"Desert of Thorns",theme:'desert',story:"A note from Alex.",
        platforms:[{x:0,y:368,w:220,h:32,type:'ground'},{x:260,y:320,w:32,h:48,type:'cactus'},{x:340,y:300,w:64,h:16,type:'brick'}],
        enemies:[{x:360,y:268,w:32,h:32,type:'goomba',vx:-1},{x:420,y:336,w:32,h:32,type:'witch',vx:0,hp:2}]},
      {id:8,name:"The Witch’s Trial",theme:'castle',story:"Prove it’s genuine.",
        platforms:[{x:0,y:368,w:220,h:32,type:'ground'},{x:280,y:320,w:80,h:16,type:'brick'}],
        enemies:[{x:300,y:288,w:32,h:32,type:'goomba',vx:-1},{x:560,y:248,w:48,h:48,type:'witch',vx:0,hp:2}]},
      {id:9,name:"Castle Approach",theme:'castle',story:"The castle looms.",
        platforms:[{x:0,y:368,w:180,h:32,type:'ground'},{x:240,y:300,w:60,h:16,type:'brick'}],
        enemies:[{x:260,y:268,w:32,h:32,type:'goomba',vx:-1}]},
      {id:10,name:"Dragon’s Castle",theme:'castle',story:"The final bargain.",
        platforms:[{x:0,y:368,w:240,h:32,type:'ground'},{x:320,y:300,w:64,h:16,type:'brick'},{x:480,y:250,w:64,h:16,type:'brick'}],
        enemies:[{x:500,y:218,w:32,h:32,type:'goomba',vx:-1},{x:820,y:168,w:80,h:80,type:'dragon',vx:0,hp:5}]}
    ];

    // --- auto-enhance: land, hurdles, coins, checkpoint ---
    function getLevelWidth(L){
      let maxX=0;
      for(const p of L.platforms) maxX=Math.max(maxX,p.x+p.w);
      for(const e of (L.enemies||[])) maxX=Math.max(maxX,e.x+e.w);
      return Math.max(DEFAULT_LEVEL_WIDTH, Math.ceil(maxX)+300);
    }
    function enhanceLevels(){
      for(const L of levels){
        const lw=getLevelWidth(L);
        L.platforms.push({x:lw-160,y:368,w:160,h:32,type:'ground'});
        L.platforms.push({x:0,y:368,w:600,h:32,type:'ground'});
        L.platforms.push({x:650,y:350,w:120,h:50,type:'lava'});
        L.platforms.push({x:980,y:350,w:90,h:50,type:'lava'});
        L.platforms.push({x:1320,y:350,w:120,h:50,type:'lava'});
        L.platforms.push({x:680,y:300,w:80,h:14,type:'moving', ax:660,bx:780,speed:1.2,phase:0.4});
        L.platforms.push({x:1000,y:280,w:70,h:14,type:'moving', ax:960,bx:1060,speed:1.6,phase:1.2});
        L.platforms.push({x:920,y:352,w:20,h:16,type:'spring'});
        L.platforms.push({x:750,y:260,w:64,h:16,type:'brick'});
        L.platforms.push({x:1160,y:230,w:64,h:16,type:'brick'});
        if(!L.coins) L.coins=[];
        const addCoinArc=(cx,cy,n,dx)=>{ for(let i=0;i<n;i++) L.coins.push({x:cx+i*dx,y:cy - Math.sin(i/n*Math.PI)*40,w:12,h:12,taken:false}); };
        addCoinArc(220, 220, 6, 22);
        addCoinArc(700, 180, 5, 22);
        addCoinArc(1200,200, 6, 22);
        if(!L.checkpoints) L.checkpoints=[];
        L.checkpoints.push({x:Math.min(lw-300, lw/2), y:368-60, w:18, h:60, reached:false});
        L.goalX = lw - 24;
      }
    }
    enhanceLevels();

    // --- state ---
    let state='menu', currentLevel=0, lives=3, score=0, t=0, transitioning=false, graceUntil=0;
    const player={x:50,y:300,w:32,h:32,vx:0,vy:0,onGround:false,dir:'right'};
    let respawnX=50, respawnY=300;
    const keys=Object.create(null);

    // --- utils ---
    const now=()=>performance.now();
    const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
    const AABB=(a,b)=>a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;
    function toast(msg){
      const el=document.createElement('div'); el.className='toast'; el.textContent=msg;
      elToasts.appendChild(el); setTimeout(()=>el.remove(),2200);
    }
    function updateHUD(){
      if(elLives) elLives.textContent=lives;
      if(elScore) elScore.textContent=score;
      if(elLevel) elLevel.textContent=currentLevel+1;
    }
    function addScore(n){ score+=n; updateHUD(); }
    function clearKeys(){ for(const k in keys) delete keys[k]; }
    function focusCanvas(){ if(document.activeElement && document.activeElement.blur) document.activeElement.blur(); canvas.focus(); }

    function snapToGround(){
      const L=levels[currentLevel]; const cx=player.x+player.w/2; let bestY=null;
      for(const p of L.platforms){
        if(p.type==='lava'||p.type==='cactus') continue;
        if(cx>=p.x && cx<=p.x+p.w && p.y>=player.y && (bestY===null||p.y<bestY)) bestY=p.y;
      }
      if(bestY===null) bestY=368;
      player.y=bestY-player.h; player.vy=0; player.onGround=true;
    }
    function setCheckpoint(x,y){ respawnX=x; respawnY=y; toast('Checkpoint!'); }
    function doRespawn(){ player.x=respawnX; player.y=respawnY; player.vx=0; player.vy=0; player.onGround=false; clearKeys(); snapToGround(); graceUntil=now()+1000; }
    function resetRespawn(){ respawnX=50; respawnY=300; }

    function restart(){ currentLevel=0; lives=3; score=0; camX=0; resetRespawn(); doRespawn(); setState('menu'); }
    function startGame(){ currentLevel=0; lives=3; score=0; camX=0; resetRespawn(); doRespawn(); setState('story'); }
    function nextLevel(){ if(currentLevel<levels.length-1){ currentLevel++; camX=0; resetRespawn(); doRespawn(); setState('story'); } else { setState('victory'); toast('You saved Alex.'); } }
    function hit(reason){ if(now()<graceUntil) return; lives=Math.max(0,lives-1); toast(reason); setState('gameover'); }

    function setState(s){
      state=s;
      show($menu, s==='menu'); show($story, s==='story'); show($gameover, s==='gameover'); show($victory, s==='victory');
      if(s==='story' && elStoryTitle && elStoryText){
        const L=levels[currentLevel]; elStoryTitle.textContent=⁠ Level ${currentLevel+1}: ${L.name} ⁠; elStoryText.textContent=L.story;
      }
      if(s==='gameover' && elLivesRemaining) elLivesRemaining.textContent=String(lives);
      if(s==='victory' && elFinalScore) elFinalScore.textContent=String(score);
      if(s==='playing'){ graceUntil=now()+800; focusCanvas(); }
      updateHUD();
    }

    // --- inputs ---
    const blockKeys=new Set(['Space','ArrowUp','ArrowLeft','ArrowRight','Enter','KeyW','KeyA','KeyD']);
    window.addEventListener('keydown',e=>{ if(blockKeys.has(e.code)) e.preventDefault(); keys[e.code]=true;
      if(state==='menu' && (e.code==='KeyS' || e.code==='Enter')) { startGame(); }
      else if(state==='story' && (e.code==='Enter' || e.code==='KeyC')) { setState('playing'); }
      else if(e.code==='KeyK') { addScore(500); toast('Level complete! +500'); nextLevel(); }
    }, {passive:false});
    window.addEventListener('keyup',e=>{ if(blockKeys.has(e.code)) e.preventDefault(); keys[e.code]=false; }, {passive:false});
    window.addEventListener('blur',clearKeys);

    // --- buttons ---
    btnStart?.addEventListener('click',()=>{ startGame(); });
    btnContinue?.addEventListener('click',()=>{ setState('playing'); });
    btnTryAgain?.addEventListener('click',()=>{ doRespawn(); setState('playing'); });
    btnRestart?.addEventListener('click',()=>{ restart(); });
    btnPlayAgain?.addEventListener('click',()=>{ restart(); });
    btnSkip?.addEventListener('click',()=>{ addScore(500); toast('Level complete! +500'); nextLevel(); });
    btnMenu?.addEventListener('click',()=>{ setState('menu'); });

    // --- world updates ---
    function updateWorld(){
      const L=levels[currentLevel];
      for(const p of L.platforms){
        if(p.type==='moving'){
          const ax=p.ax??p.x, bx=p.bx??p.x;
          const tlocal = t*(p.speed||1) + (p.phase||0);
          const u = (Math.sin(tlocal)+1)/2;
          p.x = ax + u*(bx-ax);
        }
      }
    }
    function updateEnemies(){
      const L=levels[currentLevel];
      const levelW=(L.goalX? L.goalX+24 : getLevelWidth(L));
      for(const en of (L.enemies||[])){
        en.x+=(en.vx||0);
        if(en.x<=0||en.x+en.w>=levelW){ en.vx=-(en.vx||0); en.x=clamp(en.x,0,levelW-en.w); }
      }
    }
    function updatePlayer(){
      if(keys['ArrowLeft']||keys['KeyA']){ player.vx=-SPEED; player.dir='left'; }
      else if(keys['ArrowRight']||keys['KeyD']){ player.vx=SPEED; player.dir='right'; }
      else { player.vx=0; }
      if((keys['Space']||keys['ArrowUp']||keys['KeyW']) && player.onGround){ player.vy=JUMP; player.onGround=false; }

      const prevY=player.y;
      player.vy+=GRAVITY; player.x+=player.vx; player.y+=player.vy;

      const L=levels[currentLevel];
      const levelW=(L.goalX? L.goalX+24 : getLevelWidth(L));
      player.x=clamp(player.x,0,levelW-player.w);
      player.onGround=false;

      for(const p of L.platforms){
        const collide=AABB(player,p);
        if(!collide) continue;
        if(p.type==='lava'||p.type==='cactus'){ hit(p.type==='lava'?'You fell into lava!':'Cactus hurts!'); return; }
        if(p.type==='spring'){ player.vy = JUMP*0.9; player.onGround=false; continue; }
        if(prevY+player.h<=p.y && player.vy>=0){ player.y=p.y-player.h; player.vy=0; player.onGround=true; }
      }

      const survivors=[];
      for(const en of (L.enemies||[])){
        const collide=AABB(player,en);
        if(!collide){ survivors.push(en); continue; }
        const stomp=(prevY+player.h<=en.y)&&player.vy>=0;
        if(stomp){
          player.vy=JUMP/2;
          if(typeof en.hp==='number'){ en.hp-=1; if(en.hp<=0){ addScore(150); toast('Boss defeated! +150'); } else { survivors.push(en); toast('Boss -1 HP'); } }
          else { addScore(100); toast('Enemy defeated! +100'); }
        } else { hit('Enemy hit you!'); return; }
      }
      L.enemies=survivors;

      if(L.coins){ for(const c of L.coins){ if(!c.taken && AABB(player,c)){ c.taken=true; addScore(25); } } }
      if(L.checkpoints){ for(const cp of L.checkpoints){ if(!cp.reached && AABB(player,cp)){ cp.reached=true; setCheckpoint(cp.x, cp.y); } } }

      const goal={x:(L.goalX||getLevelWidth(L)-24), y:368-60, w:18, h:60};
      if(!transitioning && AABB(player,goal)){
        transitioning=true; addScore(500); toast('Level complete! +500'); nextLevel();
        setTimeout(()=>transitioning=false,250);
      }
      if(player.y>H+24) hit('You fell! Try again!');
    }

    // camera keeps player in a horizontal dead-zone
    function updateCamera(){
      const L=levels[currentLevel];
      const levelW=(L.goalX? L.goalX+24 : getLevelWidth(L));
      const left = camX + VIEW_MARGIN_X;
      const right = camX + W - VIEW_MARGIN_X;
      if (player.x < left){
        camX = clamp(player.x - VIEW_MARGIN_X, 0, levelW - W);
      } else if (player.x + player.w > right){
        camX = clamp(player.x + player.w - (W - VIEW_MARGIN_X), 0, levelW - W);
      }
    }

    // --- render ---
    const BG={ overworld:['#87CEEB','#00BFFF'], lava:['#FF6A00','#8B0000'], ice:['#D7F1FF','#A8D8F0'], desert:['#F9E9C5','#F0C56A'], castle:['#3a3a3a','#000'] };
    function rr(x,y,w,h,r){ const a=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+a,y); ctx.arcTo(x+w,y,x+w,y+h,a); ctx.arcTo(x+w,y+h,x,y+h,a); ctx.arcTo(x,y+h,x,y,a); ctx.arcTo(x,y,x+w,y,a); ctx.closePath(); }
    function draw(){
      const L=levels[currentLevel];
      // sky (screen-space)
      const g=ctx.createLinearGradient(0,0,0,H); const [c1,c2]=BG[L.theme]||BG.overworld; g.addColorStop(0,c1); g.addColorStop(1,c2);
      ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

      // world (camera-space)
      ctx.save(); ctx.translate(-camX,0);

      // goal flag
      const goal={x:(L.goalX||getLevelWidth(L)-24), y:368-60, w:18, h:60};
      ctx.save(); ctx.globalAlpha=.9; ctx.fillStyle='#223a74'; ctx.fillRect(goal.x,goal.y,6,goal.h);
      ctx.fillStyle='#ffd54a'; ctx.beginPath(); ctx.moveTo(goal.x+6,goal.y+8); ctx.lineTo(goal.x+24,goal.y+18); ctx.lineTo(goal.x+6,goal.y+28); ctx.closePath(); ctx.fill(); ctx.restore();

      // platforms & hazards
      for(const p of L.platforms){
        let a='#CD853F',b='#8B4513';
        if(p.type==='ground'){a='#A2754A';b='#5C3B1C'}
        if(p.type==='brick'){a='#D38A6A';b='#8C4E34'}
        if(p.type==='ice'){a='#E0F8FF';b='#A6D4E6'}
        if(p.type==='cactus'){a='#3E8E41';b='#1E5B23'}
        if(p.type==='lava'){ const glow=.2*Math.sin(t*4)+.8; a=⁠ rgba(255,100,50,${glow}) ⁠; b='rgba(180,20,0,1)'; }
        if(p.type==='moving'){ a='#8EA6FF'; b='#5260B8'; }

        const pg=ctx.createLinearGradient(p.x,p.y,p.x,p.y+p.h); pg.addColorStop(0,a); pg.addColorStop(1,b);
        ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=6;

        if(p.type==='spring'){
          ctx.fillStyle='#ffd54a';
          rr(p.x,p.y,p.w,p.h,3); ctx.fill();
          ctx.fillStyle='#222'; ctx.fillRect(p.x+4,p.y+2,p.w-8,3);
        }else{
          ctx.fillStyle=pg; rr(p.x,p.y,p.w,p.h,4); ctx.fill();
          ctx.shadowBlur=0; ctx.strokeStyle='rgba(0,0,0,.5)'; ctx.stroke();
        }
      }

      // enemies
      for(const en of (L.enemies||[])){
        ctx.save(); ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=6;
        if(en.type==='goomba'){
          ctx.fillStyle='#8B5A2B'; rr(en.x,en.y,en.w,en.h,6); ctx.fill();
          ctx.fillStyle='#fff'; ctx.fillRect(en.x+6,en.y+8,6,6); ctx.fillRect(en.x+en.w-12,en.y+8,6,6);
          ctx.fillStyle='#000'; ctx.fillRect(en.x+8,en.y+10,2,2); ctx.fillRect(en.x+en.w-10,en.y+10,2,2); ctx.fillRect(en.x+en.w/2-4,en.y+20,8,2);
        } else if(en.type==='witch'){
          ctx.fillStyle='#6B2E77'; rr(en.x,en.y,en.w,en.h,6); ctx.fill(); ctx.fillStyle='#4B0082'; rr(en.x+6,en.y-12,en.w-12,12,4); ctx.fill();
        } else if(en.type==='dragon'){
          ctx.fillStyle='#B90E2B'; rr(en.x,en.y,en.w,en.h,10); ctx.fill(); ctx.fillStyle='#E64545'; rr(en.x+10,en.y-18,en.w-20,34,8); ctx.fill();
          ctx.fillStyle='#FFD54A'; ctx.fillRect(en.x+en.w/2-18,en.y-10,8,8); ctx.fillRect(en.x+en.w/2+10,en.y-10,8,8);
          ctx.fillStyle='#000'; ctx.fillRect(en.x+en.w/2-16,en.y-8,4,4); ctx.fillRect(en.x+en.w/2+12,en.y-8,4,4);
        }
        ctx.shadowBlur=0; ctx.strokeStyle='rgba(0,0,0,.6)'; ctx.strokeRect(en.x,en.y,en.w,en.h); ctx.restore();
        if(typeof en.hp==='number' && en.hp>0){ ctx.fillStyle='#ffd54a'; for(let i=0;i<en.hp;i++) ctx.fillRect(en.x+4+i*6,en.y-8,4,4); }
      }

      // coins
      if(levels[currentLevel].coins){
        for(const c of levels[currentLevel].coins){
          if(c.taken) continue;
          const cx=c.x+6, cy=c.y+6;
          ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2);
          ctx.fillStyle='#ffd54a'; ctx.fill();
          ctx.strokeStyle='#b8922a'; ctx.stroke();
        }
      }

      // checkpoints
      if(levels[currentLevel].checkpoints){
        for(const cp of levels[currentLevel].checkpoints){
          ctx.fillStyle='#223a74'; ctx.fillRect(cp.x,cp.y,6,cp.h);
          ctx.fillStyle=cp.reached?'#7CFC00':'#ffd54a';
          ctx.beginPath(); ctx.moveTo(cp.x+6,cp.y+8); ctx.lineTo(cp.x+24,cp.y+18); ctx.lineTo(cp.x+6,cp.y+28); ctx.closePath(); ctx.fill();
        }
      }

      // player
      ctx.save(); ctx.shadowColor='rgba(0,0,0,.4)'; ctx.shadowBlur=8;
      ctx.fillStyle='#1E4DD8'; rr(player.x,player.y+16,player.w,16,4); ctx.fill();
      ctx.fillStyle='#D61E1E'; rr(player.x+4,player.y+8,24,12,3); ctx.fill();
      ctx.fillStyle='#F5D3B1'; rr(player.x+8,player.y+4,16,12,3); ctx.fill();
      ctx.fillStyle='#D61E1E'; rr(player.x+6,player.y,20,8,3); ctx.fill();
      ctx.fillStyle='#000'; ctx.fillRect(player.x+10,player.y+8,2,2); ctx.fillRect(player.x+20,player.y+8,2,2);
      ctx.fillStyle='#FFD54A'; ctx.fillRect(player.x+8,player.y+20,3,3); ctx.fillRect(player.x+21,player.y+20,3,3);
      ctx.shadowBlur=0; ctx.strokeStyle='rgba(0,0,0,.6)'; ctx.strokeRect(player.x,player.y,player.w,player.h); ctx.restore();

      ctx.restore(); // end camera

      // debug
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(10,10,210,24);
      ctx.fillStyle='#fff'; ctx.font='12px system-ui'; ctx.fillText('state: '+state+'  camX: '+camX.toFixed(0),16,26);
    }

    // --- loop ---
    function updateCamera(){
      const L=levels[currentLevel];
      const levelW=(L.goalX? L.goalX+24 : getLevelWidth(L));
      const left = camX + VIEW_MARGIN_X;
      const right = camX + W - VIEW_MARGIN_X;
      if (player.x < left){
        camX = clamp(player.x - VIEW_MARGIN_X, 0, levelW - W);
      } else if (player.x + player.w > right){
        camX = clamp(player.x + player.w - (W - VIEW_MARGIN_X), 0, levelW - W);
      }
    }
    function loop(){ if(state==='playing'){ updateWorld(); updateEnemies(); updatePlayer(); updateCamera(); } draw(); t+=1/60; requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    // start
    setState('menu');
  });
  </script>
</body>
</html>