<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hero‚Äôs Sacrifice ‚Äî Characters + Themes (Chrome/Mac Fixed)</title>
<style>
  :root {
    --bg:#0b0f14; --card:#111826; --text:#e7edf5; --muted:#96a2b4;
    --primary:#6aa6ff; --accent:#ffd54a; --danger:#ff5a5f; --border:#223146;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    background:radial-gradient(1200px 600px at 50% -100px,#1a2433 0%,#0b0f14 60%);
    color:var(--text); font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;
    display:grid; place-items:center; min-height:100svh;
  }
  .wrap{width:100%;max-width:960px;padding:24px}
  .hud{display:flex;gap:16px;align-items:center;margin-bottom:12px;font-weight:700;flex-wrap:wrap}
  .hud .tag{padding:6px 10px;border:1px solid var(--border);border-radius:10px;background:#0f1624aa;backdrop-filter:blur(4px)}
  .canvas-wrap{border:4px solid var(--border);border-radius:16px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,.45)}
  canvas{display:block;background:transparent;outline:none}
  .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  button{background:#122037;color:var(--text);border:1px solid var(--border);padding:8px 14px;border-radius:10px;cursor:pointer}
  button:hover{background:#162744}

  .screen{
    position:fixed; inset:0; display:none; place-items:center; padding:24px;
    background:rgba(5,8,12,.65); backdrop-filter:blur(6px); z-index:10; pointer-events:none;
  }
  .screen.visible{ display:grid; pointer-events:auto; }
  .card{ width:min(760px,92vw); background:var(--card); border:1px solid var(--border);
    border-radius:16px; padding:24px; box-shadow:0 10px 40px rgba(0,0,0,.5) }
  .card h1,.card h2{margin:0 0 10px}
  .card p{color:var(--muted)}
  .card .actions{margin-top:18px;display:flex;gap:10px;flex-wrap:wrap}
  .btn-primary{background:#1c3b70;border-color:#31548a}
  .btn-primary:hover{background:#20437d}
  .btn-danger{background:#5a1620;border-color:#7a2030}

  .char-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin:12px 0}
  .char{border:1px solid var(--border);border-radius:12px;padding:12px;cursor:pointer;background:#0f1624aa;outline:0}
  .char[aria-checked="true"]{outline:2px solid var(--accent); background:#13223d}
  .char:focus{outline:2px solid var(--primary)}
  .char h3{margin:6px 0 4px}
  .char small{color:var(--muted)}
  /* Visually hide radios but keep them interactive (Chrome/Mac friendly) */
  .char input[type="radio"]{
    position:absolute;
    opacity:0;
    width:1px; height:1px;
    margin:0; padding:0;
    border:0;
    clip:rect(0 0 0 0);
    clip-path: inset(50%);
    overflow:hidden;
    white-space:nowrap;
  }

  .toasts{position:fixed;top:16px;right:16px;display:grid;gap:8px;z-index:20}
  .toast{background:#0f1a2c;border:1px solid var(--border);color:var(--text);padding:8px 12px;border-radius:8px;opacity:0;transform:translateY(-8px);animation:toast 2.2s ease forwards}
  @keyframes toast{
    0%{opacity:0;transform:translateY(-8px)}
    10%{opacity:1;transform:translateY(0)}
    90%{opacity:1}
    100%{opacity:0;transform:translateY(-8px)}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="tag">Lives: <span id="lives">3</span></div>
      <div class="tag">Score: <span id="score">0</span></div>
      <div class="tag">Level: <span id="level">1</span>/10</div>
      <div class="tag">Character: <span id="char-name">Manan</span></div>
      <div class="tag">Theme: <span id="theme-name">Forest</span></div>
    </div>
    <div class="canvas-wrap">
      <canvas id="game" width="800" height="400" tabindex="0" aria-label="Game canvas"></canvas>
    </div>
    <div class="controls">
      <button id="btn-skip" title="Debug">Skip Level</button>
      <button id="btn-menu">Menu</button>
    </div>
  </div>

  <!-- Menu (with character select) -->
  <div id="screen-menu" class="screen visible">
    <div class="card">
      <h1>Hero‚Äôs Sacrifice</h1>
      <p>Pick your form, then step into the woods.</p>
      <div class="char-grid" id="char-grid" role="radiogroup" aria-label="Choose character">
        <label class="char" data-key="manan" role="radio" aria-checked="true" tabindex="0">
          <input type="radio" name="character" value="manan" checked />
          <h3>üê∂ Manan</h3>
          <small>Balanced dog. Good traction, solid jump.</small>
        </label>
        <label class="char" data-key="liberator" role="radio" aria-checked="false" tabindex="0">
          <input type="radio" name="character" value="liberator" />
          <h3>üêä Liberator</h3>
          <small>Crocodile. Heavier, a bit slower, stable landings.</small>
        </label>
        <label class="char" data-key="garvit" role="radio" aria-checked="false" tabindex="0">
          <input type="radio" name="character" value="garvit" />
          <h3>ü¶Ö Garvit</h3>
          <small>Eagle. Hovers slightly above ground, lighter gravity.</small>
        </label>
      </div>
      <div class="actions">
        <button class="btn-primary" id="start">Start Adventure</button>
      </div>
    </div>
  </div>

  <!-- Story card per level -->
  <div id="screen-story" class="screen">
    <div class="card">
      <h2 id="story-title">Level 1: Forest Path</h2>
      <p id="story-text"></p>
      <div class="actions">
        <button class="btn-primary" id="continue">Continue</button>
      </div>
    </div>
  </div>

  <!-- Game Over -->
  <div id="screen-gameover" class="screen">
    <div class="card">
      <h2 style="color:var(--danger);">Game Over</h2>
      <p>Lives remaining: <span id="lives-remaining">0</span></p>
      <div class="actions">
        <button class="btn-primary" id="try-again">Try Again</button>
        <button class="btn-danger" id="restart">Restart</button>
      </div>
    </div>
  </div>

  <!-- Victory -->
  <div id="screen-victory" class="screen">
    <div class="card">
      <h2 style="color:var(--accent);">Victory!</h2>
      <p>Through courage and sacrifice, you saved your brother.</p>
      <p><strong>Final Score: <span id="final-score">0</span></strong></p>
      <div class="actions">
        <button class="btn-primary" id="play-again">Play Again</button>
      </div>
    </div>
  </div>

  <div class="toasts" id="toasts"></div>

<script>
'use strict';
window.addEventListener('DOMContentLoaded', () => {
  // ===== DOM =====
  const q = id => document.getElementById(id);
  const canvas = q('game'); const ctx = canvas.getContext('2d');
  const elLives=q('lives'), elScore=q('score'), elLevel=q('level'), elToasts=q('toasts');
  const elChar=q('char-name'), elTheme=q('theme-name');
  const $menu=q('screen-menu'), $story=q('screen-story'), $gameover=q('screen-gameover'), $victory=q('screen-victory');
  const elStoryTitle=q('story-title'), elStoryText=q('story-text'), elLivesRemaining=q('lives-remaining'), elFinalScore=q('final-score');
  const btnStart=q('start'), btnContinue=q('continue'), btnTryAgain=q('try-again'), btnRestart=q('restart'),
        btnPlayAgain=q('play-again'), btnSkip=q('btn-skip'), btnMenu=q('btn-menu');
  const grid = q('char-grid');

  // ===== Utils =====
  const W=800, H=400;
  const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const AABB=(a,b)=>a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;
  const toast=(msg)=>{ const el=document.createElement('div'); el.className='toast'; el.textContent=msg; elToasts.appendChild(el); setTimeout(()=>el.remove(),2200); };

  // ===== Character stats =====
  const CHARACTERS = {
    manan:     { label:'Manan',     emoji:'üê∂', SPEED:2.1, JUMP:-11.5, GRAVITY:0.50, HOVER:0   },
    liberator: { label:'Liberator', emoji:'üêä', SPEED:1.9, JUMP:-10.6, GRAVITY:0.56, HOVER:0   },
    garvit:    { label:'Garvit',    emoji:'ü¶Ö', SPEED:2.4, JUMP:-10.0, GRAVITY:0.38, HOVER:18  },
  };
  let currentCharKey = 'manan';
  let CH = CHARACTERS[currentCharKey];

  // ===== Themes per level =====
  const SKY = {
    forest:  [['#bfe9ff','#87c38f'], ['#9cd2ff','#6fb389'], ['#ffa673','#ffd56a']],
    cave:    [['#26324a','#3b4a67'], ['#1d2638','#324459'], ['#172035','#283b50']],
    desert:  [['#ffd28a','#f6a96d'], ['#ffbd7a','#f2945e'], ['#f07b54','#f6ce7a']],
    snow:    [['#dff2ff','#bfe0f5'], ['#cfe9ff','#acd0ef'], ['#b7d8ff','#9fbce0']],
    swamp:   [['#8fbf8a','#41634f'], ['#7aaa7e','#355744'], ['#6d946f','#2e493a']],
    dunes:   [['#fce2a8','#f6c17d'], ['#f6d593','#f1ae6c'], ['#efc173','#f4d89b']],
    grove:   [['#b9f4c4','#79be8c'], ['#9de2af','#67ad7c'], ['#8bd0a0','#5b9c70']],
    dusk:    [['#7aa0ff','#6fc38b'], ['#5e7bff','#618975'], ['#fe7a8c','#ffc66a']],
    castle:  [['#9bb2c9','#6d8296'], ['#839ab3','#5d6f83'], ['#6a839b','#536475']],
    volcanic:[['#ffb3a1','#f47c5e'], ['#ff987d','#e6654a'], ['#ff7d62','#d94b33']],
  };
  const LEVEL_THEMES = ['forest','cave','desert','snow','swamp','dunes','grove','dusk','castle','volcanic'];

  // ===== Color helpers =====
  const lerpColor=(a,b,t)=>{
    const pa=parseInt(a.slice(1),16), pb=parseInt(b.slice(1),16);
    const ar=(pa>>16)&255, ag=(pa>>8)&255, ab=pa&255;
    const br=(pb>>16)&255, bg=(pb>>8)&255, bb=pb&255;
    const r=Math.round(ar+(br-ar)*t), g=Math.round(ag+(bg-ag)*t), b2=Math.round(ab+(bb-ab)*t);
    return `#${(r<<16|g<<8|b2).toString(16).padStart(6,'0')}`;
  };
  const skyFor=(theme, prog)=>{
    const stops = SKY[theme]||SKY.forest;
    const seg = Math.min(2, Math.floor(prog*2)); // 0,1,2
    const local = (prog*2) - seg;
    const cTop = lerpColor(stops[seg][0], stops[Math.min(seg+1,2)][0], local);
    const cBot = lerpColor(stops[seg][1], stops[Math.min(seg+1,2)][1], local);
    return [cTop, cBot];
  };

  // ===== Level generation (safe route + finish island) =====
  const DEFAULT_LEVEL_WIDTH = 2200;
  const VIEW_MARGIN_X = 180;
  const GROUND_Y = 368;

  const addGround=(arr,x,w)=>arr.push({x, y:GROUND_Y, w, h:32, type:'ground'});
  const addBrick =(arr,x,y,w=64)=>arr.push({x, y, w, h:16, type:'brick'});
  const addIce   =(arr,x,y,w=80)=>arr.push({x, y, w, h:16, type:'ice'});
  const addMove  =(arr,x,y,w,ax,bx,s=1,p=0)=>arr.push({x,y,w,h:14,type:'moving',ax,bx,speed:s,phase:p});
  const addLava  =(arr,x,w)=>arr.push({x, y:GROUND_Y-18, w, h:50, type:'lava'});

  function makeLevel(i){
    const id=i+1, theme = LEVEL_THEMES[i%LEVEL_THEMES.length];
    const lw = DEFAULT_LEVEL_WIDTH + i*80;
    const titles=['Forest Path','Shadow Cavern','Sunlit Expanse','Frosted Grove','Bog Road','Amber Dunes','Ancient Grove','Evenfall','Outer Bailey','Dragon‚Äôs Keep'];
    const stories=[
      'Into the green. Alex‚Äôs trail cuts through whispering pines.',
      'Echoes cling to the wet stone.',
      'Heat shimmers across the flats.',
      'Cold breath, warm resolve.',
      'The air is thick, the ground unsure.',
      'Wind carves waves in sand.',
      'Roots remember your name.',
      'Light thins to violet.',
      'Castle walls gather on the horizon.',
      'The final bargain among ash and stone.'
    ];
    const L={ id, theme, name:titles[i], story:stories[i], platforms:[], enemies:[], coins:[], checkpoints:[], levelW:lw };

    // Start
    addGround(L.platforms, 0, 560);

    // Pits (always bridged)
    const pitCount = Math.min(2, 1 + Math.floor(i/3));
    let pitX = 740;
    for(let p=0;p<pitCount;p++){
      const pitW = 140 + 12*i + 24*p;
      addLava(L.platforms, pitX, pitW);
      const stepY = GROUND_Y-42;
      const stepCount = Math.max(2, Math.ceil(pitW/80));
      const pad = (pitW-40)/(stepCount+1);
      for(let s=1;s<=stepCount;s++) addBrick(L.platforms, pitX + s*pad, stepY, 54);
      if(i>=4 && p===0) addMove(L.platforms, pitX+pitW*0.5-35, GROUND_Y-72, 70, pitX+20, pitX+pitW-90, 1.2+0.08*i, 0.4);
      addGround(L.platforms, pitX+pitW, 420);
      pitX += pitW + 520;
    }

    // Mid/upper route
    addBrick(L.platforms, 460, GROUND_Y-60);
    addBrick(L.platforms, 560, GROUND_Y-100);
    if(i%2===0) addIce(L.platforms, 660, GROUND_Y-140, 80);
    addBrick(L.platforms, 820, GROUND_Y-100);

    // Enemies (keep away from finish)
    const base = 340 + i*24;
    for(let e=0;e<2+(i>6);e++){
      const ex = base + e*260;
      if(ex<lw-560) L.enemies.push({x:ex, y:336, w:32, h:32, type:'goomba', vx:(e%2?-1:1)});
    }
    if(i===7) L.enemies.push({x:lw-860, y:320, w:48, h:48, type:'witch', vx:0, hp:2});
    if(i===9) L.enemies.push({x:lw-920, y:288, w:80, h:80, type:'dragon', vx:0, hp:5});

    // Coins
    const arc=(cx,cy,n,dx)=>{ for(let k=0;k<n;k++) L.coins.push({x:cx+k*dx,y:cy - Math.sin(k/n*Math.PI)*40,w:12,h:12,taken:false}); };
    arc(260,220,6,22); arc(760,180,5,22); arc(lw-520,200,6,22);

    // Checkpoint mid
    L.checkpoints.push({x: Math.min(lw-420, Math.max(420, Math.floor(lw/2))), y:GROUND_Y-60, w:18, h:60, reached:false});

    // Finish island + goal line
    const finishW = 340, finishX = lw - (finishW + 200);
    addGround(L.platforms, finishX-120, 120);
    addGround(L.platforms, finishX, finishW);
    L.goal = { x: finishX + Math.floor(finishW*0.65), y: GROUND_Y - 60, w: 18, h: 60 };

    // Tail ground
    addGround(L.platforms, lw-140, 140);

    return L;
  }

  const levels = Array.from({length:10}, (_,i)=>makeLevel(i));

  // ===== Game State =====
  let state='menu', currentLevel=0, lives=3, score=0, transitioning=false, graceUntil=0, t=0;
  let camX=0;
  const player={x:50,y:300,w:32,h:32,vx:0,vy:0,onGround:false,dir:'right'};
  const keys=Object.create(null);
  let respawnX=50, respawnY=300;

  // ===== UI helpers =====
  const show=(el,vis)=>{ if(!el) return; el.classList.toggle('visible',vis); el.style.pointerEvents=vis?'auto':'none'; };
  const updateHUD=()=>{ elLives.textContent=lives; elScore.textContent=score; elLevel.textContent=currentLevel+1; elChar.textContent = CHARACTERS[currentCharKey].label; elTheme.textContent = levels[currentLevel].theme[0].toUpperCase()+levels[currentLevel].theme.slice(1); };
  const focusCanvas=()=>{ if(document.activeElement && document.activeElement.blur) document.activeElement.blur(); canvas.focus(); };
  const setCheckpoint=(x,y)=>{ respawnX=x; respawnY=y; toast('Checkpoint!'); };
  function addScore(n){ score+=n; updateHUD(); }

  // ===== Character card <-> radio sync (Chrome/Mac robust) =====
  function syncCardsFromRadios(){
    const input = document.querySelector('input[name="character"]:checked');
    const card  = input?.closest('.char');
    document.querySelectorAll('#char-grid .char').forEach(c=>{
      c.setAttribute('aria-checked', c===card ? 'true' : 'false');
    });
    if (input) {
      currentCharKey = input.value;
      CH = CHARACTERS[currentCharKey];
      elChar.textContent = CH.label;
    }
  }
  function forceSelectCard(card){
    const input = card.querySelector('input[type="radio"]');
    if (!input) return;
    if (!input.checked) {
      input.checked = true;
      input.dispatchEvent(new Event('change', { bubbles:true }));
    } else {
      syncCardsFromRadios();
    }
  }

  // Wire events
  const grid = document.getElementById('char-grid');
  grid.addEventListener('click', (e)=>{
    const card = e.target.closest('.char');
    if(card){ e.preventDefault(); forceSelectCard(card); }
  });
  grid.addEventListener('change', (e)=>{
    if(e.target && e.target.name==='character'){
      syncCardsFromRadios();
      const k=e.target.value; const C=CHARACTERS[k];
      if(C) toast(`Selected ${C.emoji} ${C.label}`);
    }
  });
  grid.addEventListener('keydown', (e)=>{
    const card = e.target.closest('.char'); if(!card) return;
    if(e.key==='Enter' || e.key===' '){ e.preventDefault(); forceSelectCard(card); }
  });

  // ===== State transitions =====
  function doRespawn(){
    player.x=respawnX; player.y=respawnY; player.vx=0; player.vy=0; player.onGround=false;
    snapToGround(); graceUntil=performance.now()+900;
    keys.Space=keys.ArrowUp=keys.KeyW=false;
  }
  function setState(s){
    state=s;
    show($menu, s==='menu'); show($story, s==='story'); show($gameover, s==='gameover'); show($victory, s==='victory');
    if(s==='story'){ const L=levels[currentLevel]; elStoryTitle.textContent=`Level ${currentLevel+1}: ${L.name}`; elStoryText.textContent=L.story; }
    if(s==='gameover') elLivesRemaining.textContent=String(lives);
    if(s==='victory') elFinalScore.textContent=String(score);
    if(s==='playing'){ graceUntil=performance.now()+800; focusCanvas(); }
    updateHUD();
  }
  function restart(){ currentLevel=0; lives=3; score=0; camX=0; respawnX=50; respawnY=300; doRespawn(); setState('menu'); }
  function startGame(){
    const input=document.querySelector('input[name="character"]:checked');
    currentCharKey = (input && input.value) || 'manan';
    CH = CHARACTERS[currentCharKey];
    syncCardsFromRadios(); // ensure UI reflects selection
    currentLevel=0; lives=3; score=0; camX=0; respawnX=50; respawnY=300; doRespawn(); setState('story');
  }
  function nextLevel(){
    if(currentLevel<levels.length-1){
      currentLevel++; camX=0; respawnX=50; respawnY=300; doRespawn(); setState('story');
    } else { setState('victory'); toast('You saved Alex.'); }
  }
  function hit(reason){ if(performance.now()<graceUntil) return; lives=Math.max(0,lives-1); toast(reason); setState('gameover'); }

  // ===== Input =====
  const blockKeys=new Set(['Space','ArrowUp','ArrowLeft','ArrowRight','Enter','KeyW','KeyA','KeyD']);
  window.addEventListener('keydown',e=>{
    if(blockKeys.has(e.code)) e.preventDefault();
    keys[e.code]=true;
    if(state==='menu' && (e.code==='Enter' || e.code==='KeyS')) startGame();
    else if(state==='story' && (e.code==='Enter' || e.code==='KeyC')) setState('playing');
    else if(e.code==='KeyK') { addScore(500); toast('Level complete! +500'); nextLevel(); }
  }, {passive:false});
  window.addEventListener('keyup',e=>{ if(blockKeys.has(e.code)) e.preventDefault(); keys[e.code]=false; }, {passive:false});
  window.addEventListener('blur',()=>{ for(const k in keys) keys[k]=false; });

  btnStart.addEventListener('click',startGame);
  btnContinue.addEventListener('click',()=>setState('playing'));
  btnTryAgain.addEventListener('click',()=>{ doRespawn(); setState('playing'); });
  btnRestart.addEventListener('click',restart);
  btnPlayAgain.addEventListener('click',restart);
  btnSkip.addEventListener('click',()=>{ addScore(500); toast('Level complete! +500'); nextLevel(); });
  btnMenu.addEventListener('click',()=>setState('menu'));

  // ===== Physics helpers =====
  function snapToGround(){
    const L=levels[currentLevel];
    const cx=player.x+player.w/2; let bestY=null;
    for(const p of L.platforms){
      if(p.type==='lava') continue;
      if(cx>=p.x && cx<=p.x+p.w && p.y>=player.y && (bestY===null||p.y<bestY)) bestY=p.y;
    }
    if(bestY===null) bestY=GROUND_Y;
    const hover = CHARACTERS[currentCharKey].HOVER||0;
    player.y=bestY-player.h-hover; player.vy=0; player.onGround=true;
  }

  // ===== Updates =====
  function updateWorld(){
    const L=levels[currentLevel];
    for(const p of L.platforms){
      if(p.type==='moving'){
        const ax=p._ax ?? p.ax ?? p.x, bx=p._bx ?? p.bx ?? p.x;
        if(p._ax==null){ p._ax=ax; p._bx=bx; }
        const u = (Math.sin(t*(p.speed||1)+(p.phase||0))+1)/2;
        p.x = ax + u*(bx-ax);
      }
    }
  }
  function updateEnemies(){
    const L=levels[currentLevel];
    for(const en of (L.enemies||[])){
      en.x+=(en.vx||0);
      if(en.x<=0||en.x+en.w>=L.levelW){ en.vx=-(en.vx||0); en.x=clamp(en.x,0,L.levelW-en.w); }
    }
  }
  function updatePlayer(){
    const C = CHARACTERS[currentCharKey];
    // input
    if(keys['ArrowLeft']||keys['KeyA']){ player.vx=-C.SPEED; player.dir='left'; }
    else if(keys['ArrowRight']||keys['KeyD']){ player.vx=C.SPEED; player.dir='right'; }
    else player.vx=0;
    if((keys['Space']||keys['ArrowUp']||keys['KeyW']) && player.onGround){ player.vy=C.JUMP; player.onGround=false; }

    const prevY=player.y;
    player.vy+=C.GRAVITY;
    player.x+=player.vx; player.y+=player.vy;

    const L=levels[currentLevel];
    player.x=clamp(player.x,0,L.levelW-player.w);
    player.onGround=false;

    // collisions
    const hover = C.HOVER||0;
    for(const p of L.platforms){
      if(AABB(player,p)){
        if(p.type==='lava'){ hit('You fell into lava!'); return; }

        if(prevY+player.h<=p.y && player.vy>=0){
          player.y=p.y-player.h-hover; player.vy=0; player.onGround=true;
          if(p.type==='moving'){
            const dir = Math.sign((p._bx??p.bx??p.x)-(p._ax??p.ax??p.x));
            player.x += dir*0.4;
          }
        } else {
          if(player.x+player.w/2 < p.x+p.w/2) player.x = p.x - player.w - 0.01;
          else player.x = p.x + p.w + 0.01;
        }
      }
    }

    // enemies
    const survivors=[];
    for(const en of (L.enemies||[])){
      if(!AABB(player,en)){ survivors.push(en); continue; }
      const stomp=(prevY+player.h<=en.y)&&player.vy>=0;
      if(stomp){
        player.vy=C.JUMP/2;
        if(typeof en.hp==='number'){ en.hp-=1; if(en.hp<=0){ addScore(150); toast('Boss defeated! +150'); } else { survivors.push(en); toast('Boss -1 HP'); } }
        else { addScore(100); toast('Enemy defeated! +100'); }
      } else { hit('Enemy hit you!'); return; }
    }
    L.enemies=survivors;

    // coins & checkpoint
    if(L.coins) for(const c of L.coins){ if(!c.taken && AABB(player,c)){ c.taken=true; addScore(25); } }
    if(L.checkpoints) for(const cp of L.checkpoints){ if(!cp.reached && AABB(player,cp)){ cp.reached=true; setCheckpoint(cp.x, cp.y); } }

    // FINISH: crossing the flag line horizontally is enough
    if(!transitioning && (player.x + player.w) >= (L.goal.x - 6)){
      transitioning = true;
      addScore(500); toast('Level complete! +500');
      nextLevel();
      setTimeout(()=>transitioning=false, 200);
    }

    // fall off world
    if(player.y>H+60) hit('You fell! Try again!');
  }

  // ===== Camera =====
  function updateCamera(){
    const L=levels[currentLevel];
    const left = camX + VIEW_MARGIN_X;
    const right = camX + W - VIEW_MARGIN_X;
    if(player.x < left) camX = clamp(player.x - VIEW_MARGIN_X, 0, L.levelW - W);
    else if(player.x + player.w > right) camX = clamp(player.x + player.w - (W - VIEW_MARGIN_X), 0, L.levelW - W);
  }

  // ===== Drawing =====
  function rr(x,y,w,h,r){ const a=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+a,y); ctx.arcTo(x+w,y,x+w,y+h,a); ctx.arcTo(x+w,y+h,x,y+h,a); ctx.arcTo(x,y+h,x,y,a); ctx.arcTo(x,y,x+w,y,a); ctx.closePath(); }
  function drawHills(color, amp, yBase, step, width){
    ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(-100, H);
    for(let x=-100; x<=width+100; x+=step){
      const y = yBase + Math.sin((x+123)*0.002)*amp + Math.cos((x-77)*0.003)*amp*0.6;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(width+120, H); ctx.closePath(); ctx.fill();
  }
  function drawTrees(width, density, yFoot, scale, seedShift, leaf='#2f6b37'){
    for(let i=0;i<Math.ceil(width/density);i++){
      const x=i*density + ((i*97+seedShift)%density)*0.2;
      const h= 50*scale + (Math.sin((x+seedShift)*0.01)*20+20)*scale;
      const trunkW=6*scale; const trunkX=x - trunkW/2, trunkY=yFoot-h*0.25;
      ctx.fillStyle='#4a3a24'; ctx.fillRect(trunkX, trunkY, trunkW, h*0.25);
      ctx.fillStyle=leaf;
      for(let t=0;t<3;t++){
        const tw = (h*0.8) - t*(h*0.2);
        const ty = trunkY - t*(h*0.22) - h*0.15;
        ctx.beginPath();
        ctx.moveTo(x, ty - h*0.18);
        ctx.lineTo(x - tw/2, ty + h*0.12);
        ctx.lineTo(x + tw/2, ty + h*0.12);
        ctx.closePath(); ctx.fill();
      }
    }
  }
  function drawPlayer(){
    const k=currentCharKey;
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.4)'; ctx.shadowBlur=8;
    if(k==='manan'){ // dog
      ctx.fillStyle='#1E4DD8'; rr(player.x,player.y+16,player.w,16,4); ctx.fill();
      ctx.fillStyle='#D61E1E'; rr(player.x+4,player.y+8,24,12,3); ctx.fill();
      ctx.fillStyle='#F5D3B1'; rr(player.x+8,player.y+4,16,12,3); ctx.fill();
      ctx.fillStyle='#000'; ctx.fillRect(player.x+10,player.y+8,2,2); ctx.fillRect(player.x+20,player.y+8,2,2);
    } else if(k==='liberator'){ // crocodile
      ctx.fillStyle='#2e8b57'; rr(player.x,player.y+6,player.w,26,6); ctx.fill();
      ctx.fillStyle='#1f6a42'; rr(player.x+2,player.y+22,player.w-4,10,4); ctx.fill();
      ctx.fillStyle='#114d31'; rr(player.x+player.w-8,player.y+10,10,8,2); ctx.fill();
      ctx.fillStyle='#000'; ctx.fillRect(player.x+player.w-4,player.y+12,3,3);
    } else { // garvit (eagle)
      const hover = CHARACTERS.garvit.HOVER;
      ctx.fillStyle='rgba(0,0,0,0.25)';
      ctx.beginPath(); ctx.ellipse(player.x+16, player.y+player.h+hover+10, 16, 6, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#8b5a2b'; rr(player.x,player.y+8,player.w,20,8); ctx.fill();
      ctx.fillStyle='#5a3a1a'; rr(player.x-10,player.y+14,12,8,4); ctx.fill(); rr(player.x+player.w-2,player.y+14,12,8,4); ctx.fill();
      ctx.fillStyle='#f5d3b1'; rr(player.x+10,player.y+2,12,10,4); ctx.fill();
      ctx.fillStyle='#000'; ctx.fillRect(player.x+14,player.y+6,2,2);
    }
    ctx.shadowBlur=0; ctx.restore();
  }
  function draw(){
    const L=levels[currentLevel];
    const prog = L.levelW>W ? camX/(L.levelW - W) : 0;
    const [c1,c2]=skyFor(L.theme, prog);
    const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,c1); g.addColorStop(1,c2);
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    const worldW=L.levelW;
    const leafColor = (L.theme==='desert'||L.theme==='dunes') ? '#9a7b3d' :
                      (L.theme==='snow') ? '#cfe6f1' :
                      (L.theme==='volcanic') ? '#7b2b20' : '#2f6b37';
    ctx.save(); ctx.translate(-camX*0.35,0); drawHills('#8fc9a3', 22, H-140, 18, worldW); ctx.restore();
    ctx.save(); ctx.translate(-camX*0.55,0); drawTrees(worldW, 160, H-60, 0.9, 13, leafColor); ctx.restore();
    ctx.save(); ctx.translate(-camX*0.75,0); drawHills('#6fa77f', 12, H-90, 22, worldW); drawTrees(worldW, 200, H-40, 0.7, 37, leafColor); ctx.restore();

    // world
    ctx.save(); ctx.translate(-camX,0);

    for(const p of L.platforms){
      let a='#CD853F',b='#8B4513';
      if(p.type==='ground'){a='#7c5a3a';b='#4e3822'}
      if(p.type==='brick'){a='#D38A6A';b='#8C4E34'}
      if(p.type==='ice'){a='#E0F8FF';b='#A6D4E6'}
      if(p.type==='lava'){ const glow=.2*Math.sin(t*4)+.8; a=`rgba(255,100,50,${glow})`; b='rgba(180,20,0,1)'; }
      if(p.type==='moving'){ a='#8EA6FF'; b='#5260B8'; }
      const pg=ctx.createLinearGradient(p.x,p.y,p.x,p.y+p.h); pg.addColorStop(0,a); pg.addColorStop(1,b);
      ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=6;
      ctx.fillStyle=pg; rr(p.x,p.y,p.w,p.h,4); ctx.fill();
      ctx.shadowBlur=0; ctx.strokeStyle='rgba(0,0,0,.5)'; ctx.stroke();
    }

    const goal=L.goal;
    ctx.save(); ctx.globalAlpha=.98;
    ctx.fillStyle='#223a74'; ctx.fillRect(goal.x,goal.y,6,goal.h);
    ctx.fillStyle='#ffd54a';
    ctx.beginPath(); ctx.moveTo(goal.x+6,goal.y+8); ctx.lineTo(goal.x+24,goal.y+18); ctx.lineTo(goal.x+6,goal.y+28); ctx.closePath(); ctx.fill();
    ctx.restore();

    // Enemies
    for(const en of (L.enemies||[])){
      ctx.save(); ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=6;
      if(en.type==='goomba'){
        ctx.fillStyle='#8B5A2B'; rr(en.x,en.y,en.w,en.h,6); ctx.fill();
        ctx.fillStyle='#fff'; ctx.fillRect(en.x+6,en.y+8,6,6); ctx.fillRect(en.x+en.w-12,en.y+8,6,6);
        ctx.fillStyle='#000'; ctx.fillRect(en.x+8,en.y+10,2,2); ctx.fillRect(en.x+en.w-10,en.y+10,2,2); ctx.fillRect(en.x+en.w/2-4,en.y+20,8,2);
      } else if(en.type==='witch'){
        ctx.fillStyle='#6B2E77'; rr(en.x,en.y,en.w,en.h,6); ctx.fill(); ctx.fillStyle='#4B0082'; rr(en.x+6,en.y-12,en.w-12,12,4); ctx.fill();
      } else if(en.type==='dragon'){
        ctx.fillStyle='#B90E2B'; rr(en.x,en.y,en.w,en.h,10); ctx.fill(); ctx.fillStyle='#E64545'; rr(en.x+10,en.y-18,en.w-20,34,8); ctx.fill();
        ctx.fillStyle='#FFD54A'; ctx.fillRect(en.x+en.w/2-18,en.y-10,8,8); ctx.fillRect(en.x+en.w/2+10,en.y-10,8,8);
        ctx.fillStyle='#000'; ctx.fillRect(en.x+en.w/2-16,en.y-8,4,4); ctx.fillRect(en.x+en.w/2+12,en.y-8,4,4);
      }
      ctx.shadowBlur=0; ctx.strokeStyle='rgba(0,0,0,.6)'; ctx.strokeRect(en.x,en.y,en.w,en.h); ctx.restore();
      if(typeof en.hp==='number' && en.hp>0){ ctx.fillStyle='#ffd54a'; for(let i=0;i<en.hp;i++) ctx.fillRect(en.x+4+i*6,en.y-8,4,4); }
    }

    // Coins
    if(L.coins){
      for(const c of L.coins){
        if(c.taken) continue;
        const cx=c.x+6, cy=c.y+6;
        ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2);
        ctx.fillStyle='#ffd54a'; ctx.fill();
        ctx.strokeStyle='#b8922a'; ctx.stroke();
      }
    }

    // Checkpoints
    if(L.checkpoints){
      for(const cp of L.checkpoints){
        ctx.fillStyle='#223a74'; ctx.fillRect(cp.x,cp.y,6,cp.h);
        ctx.fillStyle=cp.reached?'#7CFC00':'#ffd54a';
        ctx.beginPath(); ctx.moveTo(cp.x+6,cp.y+8); ctx.lineTo(cp.x+24,cp.y+18); ctx.lineTo(cp.x+6,cp.y+28); ctx.closePath(); ctx.fill();
      }
    }

    // Player
    drawPlayer();

    ctx.restore();

    // Debug HUD
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(10,10,340,24);
    ctx.fillStyle='#fff'; ctx.font='12px system-ui';
    ctx.fillText(`state: ${state}  camX: ${camX.toFixed(0)}  char: ${CHARACTERS[currentCharKey].label}`,16,26);
  }

  // ===== Loop =====
  function updateCamera(){
    const L=levels[currentLevel];
    const left = camX + VIEW_MARGIN_X;
    const right = camX + W - VIEW_MARGIN_X;
    if(player.x < left) camX = clamp(player.x - VIEW_MARGIN_X, 0, L.levelW - W);
    else if(player.x + player.w > right) camX = clamp(player.x + player.w - (W - VIEW_MARGIN_X), 0, L.levelW - W);
  }
  function loop(){
    if(state==='playing'){ updateWorld(); updateEnemies(); updatePlayer(); updateCamera(); }
    draw(); t+=1/60; requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ===== Boot =====
  function initialSnap(){ snapToGround(); }
  syncCardsFromRadios();
  initialSnap();
  setState('menu');
});
</script>
</body>
</html>